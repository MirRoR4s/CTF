题目给了n,e c, 以及s,t 其中 d = sp + t ,d是私钥指数

![1645449327232](C:\Users\镜子\AppData\Roaming\Typora\typora-user-images\1645449327232.png)

```
n = 104761374953173292488929744863165210794654068795777885288141577481002622221368522222345141465054888216685195323019389786561685227925970380642821816770602985472200153940453825122714968250922188816858014096712757866955919806714643962473332876738158067418215518151671679136192434497079441504252290233276785611599
e = 65537
c = 65928964054587881283125968144498292857628864173177955118556976763155079656459679077792117840779590338576427244089037717506889027748698067761926112680228885555444571382015302945365206338671155793788123643640188995655372264100530540193424123290247632274913224252938261740392478884552717293366009033122985923910
s = 5142613903784744424286082317496829116877907073407033860339838239164453521174213069438631369864823275015906330523317080155171707469704307761287329022024572
t = 7967501076725747803058232903884621217031867311480596291389476854702834454579805205282313799601751011483434096767204486104203547013606991412953137405179501

```

让我们回顾一下d的定义，然后对等式进行一系列化简，并把q用n//p来代替![1645449419994](C:\Users\镜子\AppData\Roaming\Typora\typora-user-images\1645449419994.png)

上图最后一句话最后化简过程是先用n/p 代替q，然后将等式两边同时乘以p.最后进行移项合并并同类项

可以看出这个最终的等式是一个关于p的二次方程，但是k依然是一个未知数，但是不要担心，我们有以下事实

![1645449697861](C:\Users\镜子\AppData\Roaming\Typora\typora-user-images\1645449697861.png)

是的那就是k的值小于65537，这意味着我们可以通过爆破k来使得这个二次方程变为一个已知的关于p的二次方程！！！

![1645449763907](C:\Users\镜子\AppData\Roaming\Typora\typora-user-images\1645449763907.png)

对爆破的至多65537个二次方程的根进行检验就可以找到真正的p，根的条件应该是能被n整除且是素数.

找到p之后就得到了q之后求欧拉函数值直接解密flag即可

其他解法：

![1645451804125](C:\Users\镜子\AppData\Roaming\Typora\typora-user-images\1645451804125.png)

```python
n = 104761374953173292488929744863165210794654068795777885288141577481002622221368522222345141465054888216685195323019389786561685227925970380642821816770602985472200153940453825122714968250922188816858014096712757866955919806714643962473332876738158067418215518151671679136192434497079441504252290233276785611599
e = 0x10001
c = 65928964054587881283125968144498292857628864173177955118556976763155079656459679077792117840779590338576427244089037717506889027748698067761926112680228885555444571382015302945365206338671155793788123643640188995655372264100530540193424123290247632274913224252938261740392478884552717293366009033122985923910
s = 5142613903784744424286082317496829116877907073407033860339838239164453521174213069438631369864823275015906330523317080155171707469704307761287329022024572
t = 7967501076725747803058232903884621217031867311480596291389476854702834454579805205282313799601751011483434096767204486104203547013606991412953137405179501
import gmpy2
def get_root(a,b,c):
    if gmpy2.iroot((b**2-(4*a*c)),2)[1]:
        deta =  gmpy2.iroot((b**2-(4*a*c)),2)[0]
        print(deta)
        root1 = (-b + deta) // (2 * a)
        #root2 = (-b - deta)//(2*a)
        return root1
    return 0

#expr1 = (k+e*s)*(p**2) + (e*t-1-(k*(n+1)))*p +k*n
from Crypto.Util.number import *
for k in range(1,65535):
    a = (k + e * s)
    b = (e * t - 1 - (k * (n + 1)))
    c = k * n
    p = get_root(a,b,c)
    if (p!=0 and n%p==0):
        q = n // p
        assert p*q==n
        print(p*q==n)
        phi = (p-1) * (q-1)
        d = gmpy2.invert(e,phi)
        print("d=",d)
        assert d == s*p + t
        m = gmpy2.powmod(c,d,n)
        print("m=",m)

        print("flag=",long_to_bytes(m))



```

