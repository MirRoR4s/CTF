---
title: TFC_CTF
mathjax: true
toc: true
date: 2022-07-29 19:12:51
categories:
tags: Crypto
---

<!--toc-->

同样总体难度不大，但是挺好玩的0_0

<!--more-->

官方的code：https://github.com/tomadimitrie/tfcctf-2022-challenges

[TOC]



## BASIC

```python
/Rn/X7n#bUc.rjzh,|eEsg,?&QI;@^ARm}UKOkICi#X.ixEmN]D
```

base91拿flag

```python
TFCCTF{sh3's_4_10..._but_0n_th3_ph_sc4l3}
```

## OBSCURE

太离谱了，这不是crypto。。。

放在记事本里面放大看就可以

```
T̶̨̧͈͍̥͚̭̜͇̻̥̘̹̝̩͍̦̜͕͉̥̳͑̎͋͊͛͗̆͐̄͂̀̒͛̉̿̏̈̕̚̚̕͝͝͝ͅF̶̡̛̛͖̝̹̹͔̟̝̟̠̩̲̱͉̻̭̻̮͓̲̮͈̜̅̔̈͐̀̾̋͊̈́͛͆̿̀̓͐̓͋̃͛̃́̑̀̽͂̋̌̐̎̕̕͘͝͠͝͝ͅC̵̢̨̨͓̞̥̠̲̗̝̯̥̥͚̙̰̣̼̻̤̳͓͙̺̤͊̍͊̌̍̎̀̅̽͊͘͘͘͜͝͠͝͝ͅÇ̶̼̫͎̬̰͓̰̭̺̼̥̮͖͗̾͐́̉͂͂͗̏̿̂̀͝͝Ṭ̷̛͓̑̓̓̒́̋̒̃̋͊̑̎͐͐̋̈̆̉́̀̏͑̀̾̎͒̾̉̃̄̊͂́͐̈́͘͘͜͝͝F̴̢̨̡̛̥̠̪̤̞͔̝̞̳̱̙̰̲̙̠̬̻̥̜͔̲̯͚̳̖̩̺͈̬͍̪̥̯͙̱͙͔̞̰̮̦̼̼͐͒͆̿̓̓͑̎͊̋͂͑̅̈́͗̃͆͊̓̆̈́͂́̆͌͂̈̔́̔̎̀̾̕̕̚͝͝͝͝͠ͅ{̴̧̡̡̛͈̻̥̙̯̜͓̥̣͔̣͐̄̂̋͋̏͋̌̍̔̀̎̿̍̈́̐̏͒̓̒̉̐́̓̓̽̕̕͝͠s̴̝̬͒̾͗̌̓͊̚ͅ3̷̢̧͓̬̳̯̜̦͉̜̗͚̗̳̩̻͉͍̼͓͍̼͚̝͔͙̗̞͎͚̼͈̹̞͋̉̆̈́͊̐̓̔͋̈͂́̔̈́͒͗̀́̂̏͒͜͝ç̷̛͉͔̮̯̳͚̘̜͇̗͖̟̫̇͋̇̑͆̀͊̈̌̅̀̿̓͊̓̀̉́̀̓̋̊͐͊̒̌͒͒̈́̒̅̀̽̾͗̾͌̃̉̾̚̚̕̕͝͝ư̵̼̑̔͌̉͆͒̅͗̆̑̌̀̀͗̒̾̎͆̇̄̃̀̒̉̂͂̀̍̃̄̈͐̈́̔̔̈́̽̚͘̕͘ͅr̵̛̼͊̽̔̋͠1̶̧̡̨̡̢̧̡̛̗̼͓̣͖̖̖̫̲̻̰͇̫̘̖̞͖̬̤͔̙̠̪̦͙̮̝̫͔͕͈̗̙͇̫̩̫͔̩͂̾͆̈́̂̌͋̕͜͜ͅͅṭ̶̡̢̢̧̨̡̡̨̧̨̛͔̜̳̥̤̰̖̩̟̬̰̖̥̹̼͈̦̥̣͇̭͎̻̻͔̪͍̻̜͎͉͙͇̣̿̑̂̈́̇̉̄͑̅͂͐̒̽́̀̏̓̂͑͐͌̈̂̔͑̐͆̐̏͆́́̾̑̈́͑͌͐̓̊̕̚͘͜ͅẙ̸̢̨̛̹̻͉͇͎̭̻̙̭͔͎̺̤̤̻͓̼̮͈̤͈͈̠̞̪̠͉̗̺̟̙͈̖̲̪̫̖͔̟̟̇̇̿̎̊̀̊̔͌̀̀͒͐͋̀̍̃͒̂̈́͆͋̍͐̑̀̓̿̓̈́͑̊̇͆̿̓͐̓̉̕͘̕̕̚͜͠͝_̷̡̡̨̡̛̛̗̩͔̫̗̭̟̣̗͙͇͇̩̣̼̟̱͖̯̥͎̽͋́̽̈́̎͗̿͊͗͂̒̓͑͛̾̄̿͛̄͛͛́͌͐̀t̷̢̛̰̟̹͖̪̝͕̭̩͚̬̙̃͐̎͐͂͒͆̒̔̊̀͛̂̿̑̀̇͊͋̇̌̅͛̀͂͋̿̈́̈́̽̍̕͝͠͝ḩ̶̢̡̡̛̺͈̺̙͚̪͕͚̹̺̥͚̦͚̺̯̬̣͚͕͔̖̝̞̖͔̙͉͔̟̼͕͖̙̐̃͋̈͛̽́̔̈͐́́̒̏̂̄̊̔̿̍̀̓̅̽̆̍̐̌̈́̋̈́̀̿̓̐́̐͌̓͘̚͘͜͠͝͠͝ͅr̸̢̡͙̼̜̬̤̗̯̪͇̩͓͕͓͓̝͇͖̎͂̏͆͝ͅ0̷̨̛̛̛̛̯̖̞̮̦̞̫̜͕̱̻̞͎̯͎̮͑̿͆̀͛̔͆̈́̈̆̑̄̅͂̇̄́̀́̒̋̇̓̍̀̈́̂̈́̀̀̂̅̅̑́͌̋̈́͘̕̕̕̚͝ų̶̧̡̢̖͓̲̞̭̗̦̠̹̥̙̱̙̥̯̗̭̩͙͔̜̙̼̻̼̞͛̂͆̀̾̃̈́͑̈́̔̈́̾̉̄̌͗̀͊̔̈́̌́͜͠͝͠g̷̢̨̡̜̩̘̺͎̮̻̼͙̱̱͈̣̳̣̻̜͒̓͗̍͌̈́͌̉͑̽̕͝͝ͅh̸̛̛͓̯̣̼̫̦̐͗̀̾̉̅̑́͌̈́͌́͑̔̈́̇̄͘̕͝͝_̶̭̹̩̳̯͙̯͕͔̼̔̈͑̉͗͌̚͜͝0̵̢̧̛͎̭̣͈̼̳͍͚͖̲͚̗̮͖̲̼͍̼̮̖̩͖̫͔̱͓̥̯̹̥͎͖̳͈̻̝̬̪̙̪̩̬̀̉̽̂̑̓̓͐̂̐̉͆̇́̂͌̈́̏͆͗̒̋̅̋̚̕͜͜͜͝͠ͅḇ̵̨̡̨͍͖͔͚̰̠͚͇̤̝̦̺͎͙̱̭̥̼̹̞͓̜̙͕͕͚͍̩͈̭̱͖̍̌̇͆̄̏̃͌͆͛̑̀͑̂̅̍̔̐̾̽̓̑̈̇͑̃̉̎͂̐̅̆́͐̿͌͗̕͘̚̕͘̕̚͘͜͝͝͝ͅͅs̸̡̨̯̬̰̠̖̟̹͈̞͎͉͉͓̠̺̹̣̲̺̬̜̝͓͓̰͍̖̹̮̹̩̥̆̾̐͘ͅç̷̡̩͍̥̘̳̺͎͉͓͖̭̝̖̹̬̗̞̲̞̬̹̼̱̫͓͙̤̤̖̦͕͓̱̝̯͇̼͚͕̳̿͆̀͒͊̎̅͐̂͗̾̀͊͑͊́̊̈͒͂̾́͂̓̓̀̏͋͂̿̆̀͒̇̚͘͝͝ͅü̶̧̨̡̲̩̥͇̘͇̣͕̞̗͓̳̗͉̲͔̻̪̪͕̖͈̪̳̤̤͈̫̹͉̞̝͖͎͕̥̻̣̖̼̰̣̰̦̈̂̿̉̋̂̔̎̓͂̎̍̾̉͂̆̈͌̐͆̓̊͋͑͒̚͜͜͠͝͠͝͝ͅr̵̨̢̨̡̡͓̭͍̲̗͍̼̬̰̗̱̩̼̰̤͓̞̤͔͇͎̪̱̱̺͈̭͆͜ͅ1̶̡̧̨̛͕̟̹͚̹̫̮̖͚̯̲̰̤̙͉͌͆̈́̽̀͗̿̓̑͒̄̌̓̓̓͗̇̒̃̑̏̊͑̋̅̎̔͂͑̔͑̈̄̉̚͘͝ṭ̶̡̼̲͓̺̝̱̮͈̱͈͔̞̙͚̝̬̳͑͌͆̀̆̄͆̀͌͐̂̽̓̾͂̀́͗͗̍͒̆̏̓͌͒͌́̒̑̐́̃͘͝͝ẏ̸̨̡̨̞̰̜̜̟̦͎̣͍͎̳̝̮̼̦͚̮̖͈̺͓̮̲̤͙̞͕̰͖̩̭̮̯̆̌̊́̀̈́̈́̓̈́͛̌̈́́̄͋̍̇̍͌͑̃̀̈̐̋̄̐̈́̉͌̀̀̀͑̏͐̄́̿̅̽͊̉͘͘͜͝͝͠ͅͅ}̴̨̧̡̨̛̛̞̝̼̫͈̝̞̣̣͈̥̫͙̻͓̯̮̻͇̤̦̼͍̱̥̞̥͔̙̹̲͈̲̥̤͚͚͕̺̫̗͍͖͎̆͗̍̈͠ͅͅ





TFCCTF{s3cur1ty_thr0ugh_0bscur1ty}
```



## MAFIOSO

```
f433c3e883a1389482c0b652660580f36ea037434fd4a67d193bc1cdc9b2cc34
```

尝试直接转bytes但是得到了没有意义的字符串，随后观察密文的长度可以发现是64位，猜测是sha256的哈希。送到网站解拿到flag



## EXCLUSIVE ORACLE

迷茫。无语了很简单的题，但是过了一周复现我忘记题目具体是啥样了。似乎是给服务器发送一个40字节的消息，然后服务器回返回一个密文。看wp的意思加密过程应该是将我们发送的消息跟flag进行异或，异或结果作为密文返回。

```python
from pwn import *
DATA = '\x00' * 40
r = remote('01.linux.challenges.ctf.thefewchosen.com', 58166)
r.recvuntil('>'.encode())
r.sendline((DATA).encode('ascii'))
xorred = eval(r.recvline().decode()).hex()
xorred_data = bytes.fromhex(xorred[80:])#2个十六进制一个字节
xorred_flag = bytes.fromhex(xorred[:80])

secret = xor(xorred_data, xorred_flag)
print(secret)
```

从dircord上关于比赛的聊天中发现了本题的讯息，好像是密钥是40字节长，然后重复地加密了两段明文，一段是flag，一段是我们输入的，然后`tzlil`通过发送TFCCTF发现了这件事情，所以他推断出来了这个情况	

![image-20220806202858420](C:\Users\mirror\Desktop\write-up\blog\source\images\image-20220806202858420.png)

![image-20220806202936007](C:\Users\mirror\Desktop\write-up\blog\source\images\image-20220806202936007.png)

## TRAIN TO PADDINGTON

第一步将flag进行pad_pt

第二步生成一个16字节的密钥

第三步进行分组加密，具体操作是将pad后的flag跟key进行分组异或，随后按照大端字节序转成bytes，将这个过程得到的bytes拼接起来得到一个密文。最后告诉我们密文的十六进制值。不难发现这其实相当于一个ECB模式的分组加密。同一个密钥key被用来加密多个明文分组。填充的手法也很简单，如果flag的长度是16的整数倍，那么填充上16个`\x3f`这个时候根据flag的格式是`TFCCTF{` 来进行已知明文攻击。尝试利用末尾的填充字符还原key，用以下脚本解密一部分密文

```python
from Crypto.Util.number import *
c = bytes.fromhex('b4b55c3ee34fac488ebeda573ab1f974bf9b2b0ee865e45a92d2f14b7bdabb6ed4872e4dd974e803d9b2ba1c77baf725')
print(c)
f = b'TFCCTF{'
l = len(f)
tmp_key = b''
for i in range(l):
    tmp_key += (f[i]^c[i]).to_bytes(1,'big')
tmp_key += (16-len(tmp_key))*b'\x00'
print(tmp_key)
c1 = c[0:16]
c2 = c[16:32]
c3 = c[32:len(c)]
assert len(c1)==len(c2)==len(c3)
M = []
m1 = b''
m2 = b''
m3 = b''
for i in range(16):
    m1 += (c1[i]^tmp_key[i]).to_bytes(1,'big')
    m2 += (c2[i]^tmp_key[i]).to_bytes(1,'big')
    m3 += (c3[i] ^ tmp_key[i]).to_bytes(1, 'big')

print(m1)
print(m2)
print(m3)
'''
b'TFCCTF{H\x8e\xbe\xdaW:\xb1\xf9t'
b'_h4s_l3Z\x92\xd2\xf1K{\xda\xbbn'
b'4t10n}?\x03\xd9\xb2\xba\x1cw\xba\xf7%'
'''


```

从最后一个恢复出的部分明文可以知道`4t10n}`后面全是填充字符加密而来，所以我们可以知道key的第7个到第16个字节，再结合我们已知知道的前7个，成功恢复key。

```python
from Crypto.Util.number import *
c = bytes.fromhex('b4b55c3ee34fac488ebeda573ab1f974bf9b2b0ee865e45a92d2f14b7bdabb6ed4872e4dd974e803d9b2ba1c77baf725')
print(c)
f = b'TFCCTF{'
l = len(f)
tmp_key = b'\xe0\xf3\x1f}\xb7\t\xd7'

print(tmp_key)
pad = b'\x3f'
h_p = b'\x03\xd9\xb2\xba\x1cw\xba\xf7%'
key1 = b''
for i in h_p:
    key1+= (ord(pad)^ i ).to_bytes(1,'big')
#print(key1)
key = tmp_key + key1
assert len(key)==16
print(key)
flag=b''
j=0
for i in range(len(c)):
    flag += (key[j]^c[i]).to_bytes(1,'big')
    j+=1
    j%=16
print(flag)


```

做完才发现题目很细心的在两个交界处加了一个问号



## ADMIN PANEL

读题之后发现是输入正确的密码就可以获取flag。

选项2提供了一个改密的功能，在这里有一个关键点就是我们可以修改密码，并且修改的密码我们可以想办法获得。我们先输入一个长为64的十六进制token，然后服务器那边会随机生成一个字节，然后跟我们发送的token进行异或。最后的异或值经过decrypt函数就是修改后的PASSWD,这里只需要注意如果我们发送token为全0，然后这个token只跟一个字节异或然后送去decrypt，这就导致b的值固定不变。所以我们的操作就是发个token过去，然后本地爆破出256个可能的b，然后向服务器请求256个可能的decrypt(xorred)

```python
from Crypto.Util.number import *
from pwn import *
from Crypto.Cipher import AES
KEY = os.urandom(16)
def xor(byte, bytes_second):
    d = b''
    for i in range(len(bytes_second)):
        d += bytes([byte ^ bytes_second[i]])
    return d

def decrypt(ciphertext):
    iv = ciphertext[:16]
    ct = ciphertext[16:]
    #pt = b''
    state = iv
    M = []
    for b in range(256):
        pt = b''
        for i in range(len(ct)):
            c = b ^ ct[i]
            pt += bytes([c])
            state = state[1:] + bytes([ct[i]])
        M.append(pt)
    return M

a = '00'*32
print(a)
hex_token = bytes.fromhex(a)
ip = "01.linux.challenges.ctf.thefewchosen.com"
port = 54089
r = remote(ip,port)
r.recvuntil(b'> ')
r.sendline(b"2")
r.recvuntil(b"Token > ")
r.sendline(a.encode())

r.recvuntil(b"XORing with: ")
r_byte = r.recvline()
r_byte = r_byte.replace(b'\n',b'')
#print(xor)
#r.sendline(b'1')
r_byte = r_byte.decode()
#print('r_byte=',r_byte)
c = bytes.fromhex(r_byte)
xorred = xor(c[0], hex_token)
M = decrypt(xorred)
r.recv()
for i in M:
    r.sendline(b"1")
    print(r.recv())
    m = i.hex()
    print(m.encode())
    r.sendline(m.encode())
    print(r.recv())
r.interactive()
```



## ADMIN PANEL BUT HARDER

啊这。。源码丢了，好像跟压轴题差不多，我忘记了。

## ADMIN PANEL BUT HARDER AND FIXED-python的伪随机数预测

题目：

```python
import os
import random

from Crypto.Cipher import AES

KEY = os.urandom(16)
PASSWORD = os.urandom(16)
FLAG = os.getenv('FLAG')

menu = """========================
1. Access Flag
2. Change Password
========================"""


def xor(bytes_first, bytes_second):
    d = b''
    for i in range(len(bytes_second)):
        d += bytes([bytes_first[i] ^ bytes_second[i]])
    return d


def decrypt(ciphertext):
    iv = ciphertext[:16]
    ct = ciphertext[16:]
    cipher = AES.new(KEY, AES.MODE_ECB)
    pt = b''
    state = iv
    for i in range(len(ct)):
        b = cipher.encrypt(state)[0]
        c = b ^ ct[i]
        pt += bytes([c])
        state = state[1:] + bytes([ct[i]])
    return pt


if __name__ == "__main__":
    while True:
        print(menu)
        option = int(input("> "))
        if option == 1:
            password = bytes.fromhex(input("Password > "))
            if password == PASSWORD:
                print(FLAG)
                exit(0)
            else:
                print("Wrong password!")
                continue
        elif option == 2:
            token = input("Token > ").strip()
            if len(token) != 64:
                print("Wrong length!")
                continue
            hex_token = bytes.fromhex(token)
            r_bytes = random.randbytes(32)
            print(f"XORing with: {r_bytes.hex()}")
            xorred = xor(r_bytes, hex_token)
            PASSWORD = decrypt(xorred)

```

随机生成的密钥是32个字节了，这就使得我们可以控制的state无法保持一个值不变。题目变得困难起来。

之前做题的时候就想着可不可以让传入decrypt函数的值为全0，这样16轮的b值都是一样的，只需要枚举256个可能的b就可以解出flag。但是由于`r_bytes`是后于我们发送的信息生成，然后我就卡住了。

后面看答案是提到利用`random.randbytes` 的弱点去预测出这个`r_bytes`来。具体的预测原理我没有关注，是利用一个叫做https://github.com/kmyk/mersenne-twister-predictor的工具，利用条件是要有624个32bit的整数。回到本题中来，我们可以不断地向服务器发起请求，然后就可以获得一个32字节的r_bytes。但是问题在于32字节的r_bytes跟32bit的整数有关系吗？答案是有！

可以看如下的测试：

```python
import random
from libnum import n2s
random.seed(0)
test1 = ' '.join([n2s(random.getrandbits(32)).hex() for _ in range(8)])
random.seed(0)
test2 = random.randbytes(32).hex()
test2 = ' '.join([test2[i:i+8] for i in range(0,len(test2), 8)])
print(f"Test 1: {test1}")
print(f"Test 2: {test2}")

# Test 1: d82c07cd 629f6fbe c2094cac e3e70682 6baa9455 0a5d2f34 42485e3a f728b4fa
# Test 2: cd072cd8 be6f9f62 ac4c09c2 8206e7e3 5594aa6b 342f5d0a 3a5e4842 fab428f7
```

​	我们发现`randbytes(32)`按照8个字节分组 正好是  8次 `getrandbits(32)`得到的十六进制数的逆序(每一组)。猜测是由于字节序不同而导致的，但无论如何这告诉我们`randbytes(32)`可以转成一个32bit的数字。 所以我们现在只要得到624个32比特的数字就可以预测出`r_bytes`的值。我们换算一下，一次请求可以得到一个32字节也就是256比特的数据，我们需要$624*32$比特的数据，所以我们最终需要$624/8$个次请求

```python
# nc 01.linux.challenges.ctf.thefewchosen.com 50682

from pwn import *
from libnum import *
from mt19937predictor import MT19937Predictor
from tqdm import trange
from Crypto.Cipher import AES
host, port = "01.linux.challenges.ctf.thefewchosen.com", 53505



def local():
    predictor = MT19937Predictor()
    KEY = b'a'*16

    def xor(bytes_first, bytes_second):
        d = b''
        for i in range(len(bytes_second)):
            d += bytes([bytes_first[i] ^ bytes_second[i]])
        return d

    def decrypt(ciphertext):
        iv = ciphertext[:16]
        ct = ciphertext[16:]
        cipher = AES.new(KEY, AES.MODE_ECB)
        pt = b''
        state = iv
        for i in range(len(ct)):
            b = cipher.encrypt(state)[0]
            c = b ^ ct[i]
            pt += bytes([c])
            state = state[1:] + bytes([ct[i]])
        return pt
    random.seed(0)
    rs = [random.randbytes(32).hex() for _ in range(624//8)]
    cs = 0
    for res in rs:
        res = bytes.fromhex(res)
        res = [s2n(res[i:i+4][::-1]) for i in range(0,len(res),4)]
        for i in res:
            cs += 1
            predictor.setrandbits(i,32)
    print("Total count:", cs)
    predicted = [predictor.getrandbits(32) for i in range(8)]
    predicted = b''.join([n2s(i)[::-1] for i in predicted])

    r_bytes = random.randbytes(32)
    print(r_bytes)
    print(predicted)
    assert r_bytes == predicted

    hex_token = predicted.hex()
    xorred = xor(bytes.fromhex(r_bytes.hex()), bytes.fromhex(hex_token))
    PASSWORD = decrypt(xorred)
    print(PASSWORD)
    breakpoint()


def solve():
    predictor = MT19937Predictor()
    p = remote(host, port)
    count = 0
    for _ in range(624//8):
        print("Count;", count)
        if count == 624: break
        p.sendline(b'2')
        p.sendlineafter(b'Token > ', b'a'*64)
        p.recvuntil(b'XORing with: ')
        res = p.recvline().strip().decode('utf-8')
        res = bytes.fromhex(res)
        res = [s2n(res[i:i+4][::-1]) for i in range(0,len(res),4)]

        for i in res:
            count += 1
            predictor.setrandbits(i, 32)

    print("Count:", count)
    predicted = [predictor.getrandbits(32) for i in range(8)]
    predicted = b''.join([n2s(i)[::-1] for i in predicted])
    print("Predicted:", predicted)
    p.sendline(b'2')
    p.sendlineafter(b'Token > ', predicted.hex().encode())


    for i in trange(256):
        pw = (bytes([i]).hex())*16
        p.sendline(b'1')
        p.sendlineafter(b'Password > ', pw.encode())
        line = p.recvline()
        if b'Wrong pass' not in line:
            print(line)
            p.interactive()


    breakpoint()

# local()
solve()
```

wp番外：

Note that the challenge could be solved by passing `b'00' + ' '*60 + b'00'` as the token, this will cause `bytes.fromhex(token)` to read it as `b'\x00\x00'`. The xorred value will only be 2 bytes long as well, so in the `decrypt` function,

```
iv = ciphertext[:16]
ct = ciphertext[16:]
```

There is no `ct` so the password comes out as an empty string, so giving an empty string for password will leak the flag.

想法就是利用空格填充长度，然后服务器就读到了一个长为64的，但是实际内容是两个空字节的数据。这样最终传到解密函数的数据就只有2个字节，16的长度。所以ct是空的，那么显然加密结果是空，这时候随便发一个空字节就可以拿到flag。

这个完全就是非预期了，这说明密钥体制的安全性真是跟代码实现息息相关，必须对用户传入的参数做严格的检查。
